/*
 * Copyright (c) 2014 Alvaro Agea.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.rogerfs.common.utils;

import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;


/**
 * The goods are here: www.ietf.org/rfc/rfc4122.txt.
 */
public class UUIDGen {
  // A grand day! millis at 00:00:00.000 15 Oct 1582.
  private static final long START_EPOCH = -12219292800000L;
  private static final long clockSeqAndNode = makeClockSeqAndNode();

  // placement of this singleton is important. It needs to be instantiated *AFTER* the other
  // statics.
  private static final UUIDGen instance = new UUIDGen();

  private long lastNanos;

  private UUIDGen() {
    // make sure someone didn't whack the clockSeqAndNode by changing the order of instantiation.
    if (clockSeqAndNode == 0)
      throw new RuntimeException("singleton instantiation is misplaced.");
  }

  /**
   * Creates a type 1 UUID (time-based UUID).
   *
   * @return a UUID instance
   */
  public static UUID getTimeUUID() {
    return new UUID(instance.createTimeSafe(), clockSeqAndNode);
  }

  private static long makeClockSeqAndNode() {
    long clock = new Random(System.currentTimeMillis()).nextLong();

    long lsb = 0;
    lsb |= 0x8000000000000000L; // variant (2 bits)
    lsb |= (clock & 0x0000000000003FFFL) << 48; // clock sequence (14 bits)
    lsb |= makeNode(); // 6 bytes
    return lsb;
  }

  // needs to return two different values for the same when.
  // we can generate at most 10k UUIDs per ms.
  private synchronized long createTimeSafe() {
    long nanosSince = (System.currentTimeMillis() - START_EPOCH) * 10000;
    if (nanosSince > lastNanos)
      lastNanos = nanosSince;
    else
      nanosSince = ++lastNanos;

    return createTime(nanosSince);
  }

  private static long createTime(long nanosSince) {
    long msb = 0L;
    msb |= (0x00000000ffffffffL & nanosSince) << 32;
    msb |= (0x0000ffff00000000L & nanosSince) >>> 16;
    msb |= (0xffff000000000000L & nanosSince) >>> 48;
    msb |= 0x0000000000001000L; // sets the version to 1.
    return msb;
  }

  private static Collection<InetAddress> getAllLocalAddresses() {
    Set<InetAddress> localAddresses = new HashSet<InetAddress>();
    try {
      Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();
      if (nets != null) {
        while (nets.hasMoreElements())
          localAddresses.addAll(Collections.list(nets.nextElement().getInetAddresses()));
      }
    } catch (SocketException e) {
      throw new AssertionError(e);
    }
    return localAddresses;
  }

  private static long makeNode() {
    /*
     * We don't have access to the MAC address but need to generate a node part that identify this
     * host as uniquely as possible. The spec says that one option is to take as many source that
     * identify this node as possible and hash them together. That's what we do here by gathering
     * all the ip of this host. Note that FBUtilities.getBroadcastAddress() should be enough to
     * uniquely identify the node *in the cluster* but it triggers DatabaseDescriptor instanciation
     * and the UUID generator is used in Stress for instance, where we don't want to require the
     * yaml.
     */
    Collection<InetAddress> localAddresses = getAllLocalAddresses();
    if (localAddresses.isEmpty())
      throw new RuntimeException(
          "Cannot generate the node component of the UUID because cannot retrieve any IP addresses.");

    // ideally, we'd use the MAC address, but java doesn't expose that.
    byte[] hash = hash(localAddresses);
    long node = 0;
    for (int i = 0; i < Math.min(6, hash.length); i++)
      node |= (0x00000000000000ff & (long) hash[i]) << (5 - i) * 8;
    assert (0xff00000000000000L & node) == 0;

    // Since we don't use the mac address, the spec says that multicast
    // bit (least significant bit of the first octet of the node ID) must be 1.
    return node | 0x0000010000000000L;
  }

  private static byte[] hash(Collection<InetAddress> data) {
    try {
      MessageDigest messageDigest = MessageDigest.getInstance("MD5");
      for (InetAddress addr : data)
        messageDigest.update(addr.getAddress());

      return messageDigest.digest();
    } catch (NoSuchAlgorithmException nsae) {
      throw new RuntimeException("MD5 digest algorithm is not available", nsae);
    }
  }
}


